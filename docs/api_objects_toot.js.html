<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>FediAlgo Source: api/objects/toot.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api/objects/toot.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" &amp;&amp; typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;
};
var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" &amp;&amp; typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mostRecentTootedAt = exports.earliestTootedAt = exports.sortByCreatedAt = exports.mostRecentToot = exports.earliestToot = exports.tootedAt = exports.UNKNOWN = exports.JUST_MUTING = void 0;
/**
 * Helper functions and class for dealing with Toot (Mastodon status) objects.
 * Includes methods for scoring, filtering, deduplication, and property repair.
 * @module Toot
 */
const change_case_1 = require("change-case");
const class_transformer_1 = require("class-transformer");
const account_1 = __importDefault(require("./account"));
const api_1 = __importDefault(require("../api"));
const mastodon_server_1 = __importDefault(require("../mastodon_server"));
const scorer_1 = __importDefault(require("../../scorer/scorer"));
const time_helpers_1 = require("../../helpers/time_helpers");
const config_1 = require("../../config");
const numeric_filter_1 = require("../../filters/numeric_filter");
const language_helper_1 = require("../../helpers/language_helper");
const math_helper_1 = require("../../helpers/math_helper");
const environment_helpers_1 = require("../../helpers/environment_helpers");
const logger_1 = require("../../helpers/logger");
const enums_1 = require("../../enums");
const tag_1 = require("./tag");
const enums_2 = require("../../enums");
const collection_helpers_1 = require("../../helpers/collection_helpers");
const string_helpers_1 = require("../../helpers/string_helpers");
// https://docs.joinmastodon.org/entities/Status/#visibility
var TootVisibility;
(function (TootVisibility) {
    TootVisibility["DIRECT_MSG"] = "direct";
    TootVisibility["PUBLIC"] = "public";
    TootVisibility["PRIVATE"] = "private";
    TootVisibility["UNLISTED"] = "unlisted";
})(TootVisibility || (TootVisibility = {}));
;
var TootCacheKey;
(function (TootCacheKey) {
    TootCacheKey["CONTENT_STRIPPED"] = "contentStripped";
    TootCacheKey["CONTENT_WITH_EMOJIS"] = "contentWithEmojis";
    TootCacheKey["CONTENT_WITH_CARD"] = "contentWithCard";
})(TootCacheKey || (TootCacheKey = {}));
;
exports.JUST_MUTING = "justMuting"; // Used in the filter settings to indicate that the user is just muting this toot
exports.UNKNOWN = "unknown";
const MAX_CONTENT_PREVIEW_CHARS = 110;
const MAX_ID_IDX = 2;
const MIN_CHARS_FOR_LANG_DETECT = 8;
const BSKY_BRIDGY = 'bsky.brid.gy';
const HASHTAG_LINK_REGEX = /&lt;a href="https:\/\/[\w.]+\/tags\/[\w]+" class="[-\w_ ]*hashtag[-\w_ ]*" rel="[a-z ]+"( target="_blank")?>#&lt;span>[\w]+&lt;\/span>&lt;\/a>/i;
const HASHTAG_PARAGRAPH_REGEX = new RegExp(`^&lt;p>(${HASHTAG_LINK_REGEX.source} ?)+&lt;/p>`, "i");
const PROPS_THAT_CHANGE = numeric_filter_1.FILTERABLE_SCORES.concat("numTimesShown");
// We always use containsTag() instead of containsString() for these
const TAG_ONLY_STRINGS = new Set([
    "in",
    "it",
    "ja",
    "la",
    "mastodon",
    "press",
    "tv",
    "un",
    "us",
]);
const tootLogger = new logger_1.Logger("Toot");
const repairLogger = tootLogger.tempLogger("repairToot");
;
;
/**
 * Class representing a Mastodon Toot (status) with helper methods for scoring, filtering, and more.
 * @implements {TootObj}
 */
class Toot {
    // Props from mastodon.v1.Status
    id;
    uri;
    application;
    account;
    content;
    createdAt;
    editedAt = null;
    emojis;
    favouritesCount;
    mediaAttachments;
    mentions;
    reblogsCount;
    repliesCount;
    sensitive;
    spoilerText;
    tags;
    visibility;
    // Optional fields
    bookmarked;
    card;
    favourited;
    filtered;
    language;
    inReplyToAccountId;
    inReplyToId;
    muted;
    pinned;
    poll;
    reblog;
    reblogged;
    text;
    url;
    // extensions to mastodon.v1.Status. Most of these are set in completeProperties()
    completedAt;
    followedTags; // Array of tags that the user follows that exist in this toot
    numTimesShown;
    participatedTags; // Array of tags that the user has participated in that exist in this toot
    reblogsBy; // The accounts that retooted this toot
    resolvedID; // This Toot with URLs resolved to homeserver versions
    scoreInfo; // Scoring info for weighting/sorting this toot
    sources; // Source of the toot (e.g. trending tag toots, home timeline, etc.)
    trendingLinks; // Links that are trending in this toot
    trendingRank; // Most trending on a server gets a 10, next is a 9, etc.
    trendingTags; // Tags that are trending that appear in this toot
    audioAttachments;
    imageAttachments;
    videoAttachments;
    // Temporary caches for performance (profiler said contentWithCard() was using a lot of runtime)
    contentCache = {};
    // Array with the author of the toot and (if it exists) the account that retooted it.
    get accounts() { return this.withRetoot.map((toot) => toot.account); }
    ;
    /** Age of this toot in hours */
    get ageInHours() { return (0, time_helpers_1.ageInHours)(this.createdAt); }
    ;
    /** Return the account that posted this toot, not the account that reblogged it. */
    get author() { return this.realToot.account; }
    ;
    /** True if the toot is a direct message (DM) to the user. */
    get isDM() { return this.visibility === TootVisibility.DIRECT_MSG; }
    ;
    /** True if this toot is from a followed account or contains a followed tag. */
    get isFollowed() { return !!(this.accounts.some(a => a.isFollowed) || this.realToot.followedTags?.length); }
    ;
    /** True if it's for followers only. */
    get isPrivate() { return this.visibility === TootVisibility.PRIVATE; }
    ;
    /** True if it's a trending toot or contains any trending hashtags or links. */
    get isTrending() { return !!(this.trendingRank || this.trendingLinks?.length || this.trendingTags?.length); }
    ;
    /** Sum of the trendingRank, numReblogs, replies, and local server favourites. Currently unused. */
    get popularity() { return (0, collection_helpers_1.sumArray)([this.favouritesCount, this.reblogsCount, this.repliesCount, this.trendingRank]); }
    ;
    /** Return the toot that was reblogged if it's a reblog, otherwise return this toot. */
    get realToot() { return this.reblog ?? this; }
    ;
    /** URI for the realToot. @returns {string} */
    get realURI() { return this.realToot.uri; }
    ;
    /** Default to this.realURI if url property is empty. */
    get realURL() { return this.realToot.url || this.realURI; }
    ;
    /** Get the webfinger URIs of the accounts mentioned in the toot + the author prepended with @. */
    get replyMentions() { return [this.author.webfingerURI].concat((this.mentions || []).map((m) => m.acct)).map(string_helpers_1.at); }
    ;
    /** Current overall score for this toot. */
    get score() { return this.scoreInfo?.score || 0; }
    ;
    /** Timestamp of toot's createdAt // * TODO: should this consider the values in reblogsBy? */
    get tootedAt() { return new Date(this.createdAt); }
    ;
    /** Returns the toot and the retoot, if it exists, as an array. */
    get withRetoot() { return [this, ...(this.reblog ? [this.reblog] : [])]; }
    ;
    /**
     * Return 'video' if toot contains a video, 'image' if there's an image, undefined if no attachments.
     * @returns {MediaCategory | undefined}
     */
    get attachmentType() {
        if (this.imageAttachments.length > 0) {
            return enums_1.MediaCategory.IMAGE;
        }
        else if (this.videoAttachments.length > 0) {
            return enums_1.MediaCategory.VIDEO;
        }
        else if (this.audioAttachments.length > 0) {
            return enums_1.MediaCategory.AUDIO;
        }
    }
    /**
     * If the final &lt;p> paragraph of the content is just hashtags, return it.
     * @returns {string | undefined}
     */
    get contentTagsParagraph() {
        const finalParagraph = this.contentParagraphs().slice(-1)[0];
        return HASHTAG_PARAGRAPH_REGEX.test(finalParagraph) ? finalParagraph : undefined;
    }
    /**
     * Alternate constructor because class-transformer doesn't work with constructor arguments.
     * @param {SerializableToot} toot - The toot data to build from.
     * @returns {Toot} The constructed Toot instance.
     */
    static build(toot) {
        const tootObj = new Toot();
        tootObj.id = toot.id;
        tootObj.uri = toot.uri;
        tootObj.account = account_1.default.build(toot.account);
        tootObj.application = toot.application;
        tootObj.bookmarked = toot.bookmarked;
        tootObj.card = toot.card;
        tootObj.content = toot.content;
        tootObj.createdAt = toot.createdAt;
        tootObj.editedAt = toot.editedAt;
        tootObj.emojis = toot.emojis;
        tootObj.favourited = toot.favourited;
        tootObj.favouritesCount = toot.favouritesCount;
        tootObj.filtered = toot.filtered;
        tootObj.inReplyToAccountId = toot.inReplyToAccountId;
        tootObj.inReplyToId = toot.inReplyToId;
        tootObj.language = toot.language;
        tootObj.mediaAttachments = toot.mediaAttachments || [];
        tootObj.mentions = toot.mentions;
        tootObj.muted = toot.muted;
        tootObj.pinned = toot.pinned;
        tootObj.poll = toot.poll;
        tootObj.reblogged = toot.reblogged;
        tootObj.reblogsCount = toot.reblogsCount;
        tootObj.repliesCount = toot.repliesCount;
        tootObj.sensitive = toot.sensitive;
        tootObj.spoilerText = toot.spoilerText;
        tootObj.tags = toot.tags;
        tootObj.text = toot.text;
        tootObj.url = toot.url;
        tootObj.visibility = toot.visibility;
        // Unique to fedialgo
        tootObj.numTimesShown = toot.numTimesShown || 0;
        tootObj.completedAt = toot.completedAt;
        tootObj.followedTags = toot.followedTags;
        tootObj.reblog = toot.reblog ? Toot.build(toot.reblog) : undefined;
        // TODO: the reblogsBy don't necessarily have the isFollowed flag set correctly
        tootObj.reblogsBy = (toot.reblogsBy ?? []).map(account => account_1.default.build(account));
        tootObj.resolvedID = toot.resolvedID;
        tootObj.scoreInfo = toot.scoreInfo;
        tootObj.sources = toot.sources;
        tootObj.trendingLinks = toot.trendingLinks;
        tootObj.trendingRank = toot.trendingRank;
        tootObj.trendingTags = toot.trendingTags;
        tootObj.repair();
        // These must be set after repair() has a chance to fix any broken media types
        tootObj.audioAttachments = tootObj.attachmentsOfType(enums_1.MediaCategory.AUDIO);
        tootObj.imageAttachments = tootObj.attachmentsOfType(enums_1.MediaCategory.IMAGE);
        tootObj.videoAttachments = string_helpers_1.VIDEO_TYPES.flatMap((videoType) => tootObj.attachmentsOfType(videoType));
        if (tootObj.account.suspended) {
            tootLogger.warn(`Toot from suspended account:`, tootObj);
        }
        else if (tootObj.account.limited) {
            tootLogger.trace(`Toot from limited account:`, tootObj);
        }
        return tootObj;
    }
    /**
     * True if toot contains 'str' in the tags, the content, or the link preview card description.
     * @param {string} str - The string to search for.
     * @returns {boolean}
     */
    containsString(str) {
        return (0, string_helpers_1.wordRegex)(str).test(this.contentWithCard());
    }
    /**
     * Return true if the toot contains the tag or hashtag. If fullScan is true uses containsString() to search.
     * @param {TagWithUsageCounts} tag - The tag to search for.
     * @param {boolean} [fullScan] - Whether to use full scan.
     * @returns {boolean}
     */
    containsTag(tag, fullScan) {
        if (fullScan &amp;&amp; (tag.name.length > 1) &amp;&amp; !TAG_ONLY_STRINGS.has(tag.name)) {
            if (!tag.regex) {
                tootLogger.warn(`containsTag() called on tag without regex:`, tag);
                tag.regex = (0, string_helpers_1.wordRegex)(tag.name);
            }
            return tag.regex.test(this.contentWithCard());
        }
        else {
            return this.tags.some((t) => t.name == tag.name);
        }
    }
    /**
     * Generate a string describing the followed and trending tags in the toot.
     * @returns {string | undefined}
     */
    containsTagsMsg() {
        let msgs = [
            this.containsTagsOfTypeMsg(enums_2.TypeFilterName.FOLLOWED_HASHTAGS),
            this.containsTagsOfTypeMsg(enums_2.TypeFilterName.TRENDING_TAGS),
            this.containsTagsOfTypeMsg(enums_2.TypeFilterName.PARTICIPATED_TAGS),
        ];
        msgs = msgs.filter((msg) => msg);
        return msgs.length ? `Contains ${msgs.join("; ")}` : undefined;
    }
    /**
     * Returns true if the fedialgo user is mentioned in the toot.
     * @returns {boolean}
     */
    containsUserMention() {
        return this.mentions.some((mention) => mention.acct == api_1.default.instance.user.webfingerURI);
    }
    /**
     * Return all but the last paragraph if that last paragraph is just hashtag links.
     * @param {number} [fontSize=DEFAULT_FONT_SIZE]
     * @returns {string}
     */
    contentNonTagsParagraphs(fontSize = string_helpers_1.DEFAULT_FONT_SIZE) {
        const paragraphs = this.contentParagraphs(fontSize);
        if (this.contentTagsParagraph)
            paragraphs.pop(); // Remove the last paragraph if it's just hashtags
        return paragraphs.join("\n");
    }
    /**
     * Break up the content into paragraphs and add &lt;img> tags for custom emojis.
     * @param {number} [fontSize=DEFAULT_FONT_SIZE]
     * @returns {string[]}
     */
    contentParagraphs(fontSize = string_helpers_1.DEFAULT_FONT_SIZE) {
        return (0, string_helpers_1.htmlToParagraphs)(this.contentWithEmojis(fontSize));
    }
    /**
     * Shortened string of content property stripped of HTML tags.
     * @param {number} [maxChars]
     * @returns {string}
     */
    contentShortened(maxChars) {
        maxChars ||= MAX_CONTENT_PREVIEW_CHARS;
        let content = this.contentString();
        content = (0, string_helpers_1.replaceHttpsLinks)(content);
        // Fill in placeholders if content string is empty, truncate it if it's too long
        if (content.length == 0) {
            let mediaType = this.attachmentType ? `${this.attachmentType}` : "empty";
            content = `&lt;${(0, change_case_1.capitalCase)(mediaType)} post by ${this.author.describe()}>`;
        }
        else if (content.length > MAX_CONTENT_PREVIEW_CHARS) {
            content = `${content.slice(0, MAX_CONTENT_PREVIEW_CHARS)}...`;
        }
        return content;
    }
    /**
     * Replace custom emoji shortcodes (e.g. ":myemoji:") with image tags.
     * @param {number} [fontSize=DEFAULT_FONT_SIZE]
     * @returns {string}
     */
    contentWithEmojis(fontSize = string_helpers_1.DEFAULT_FONT_SIZE) {
        if (!this.contentCache[TootCacheKey.CONTENT_WITH_EMOJIS]) {
            this.contentCache[TootCacheKey.CONTENT_WITH_EMOJIS] = this.addEmojiHtmlTags(this.content, fontSize);
        }
        return this.contentCache[TootCacheKey.CONTENT_WITH_EMOJIS];
    }
    /**
     * String that describes the toot in not so many characters.
     * @returns {string}
     */
    describe() {
        let msg = `${this.account.describe()} [${(0, time_helpers_1.toISOFormat)(this.createdAt)}, ID="${this.id}"]`;
        return `${msg}: "${this.contentShortened()}"`;
    }
    /**
     * Fetch the conversation (context) for this toot (Mastodon API calls this a 'context').
     * @returns {Promise&lt;Toot[]>}
     */
    async getConversation() {
        const source = 'getConversation';
        const logger = tootLogger.tempLogger(source);
        logger.debug(`Fetching conversation for toot:`, this.describe());
        const startTime = new Date();
        const context = await api_1.default.instance.api.v1.statuses.$select(await this.resolveID()).context.fetch();
        const toots = await Toot.buildToots([...context.ancestors, this, ...context.descendants], source, true);
        logger.trace(`Fetched ${toots.length} toots ${(0, time_helpers_1.ageString)(startTime)}`, toots.map(t => t.describe()));
        return toots;
    }
    /**
     * Get an individual score for this toot.
     * @param {ScoreType} scoreType - The score type.
     * @param {ScoreName} name - The score name.
     * @returns {number}
     */
    getIndividualScore(scoreType, name) {
        if ((0, math_helper_1.isNumber)(this.scoreInfo?.scores?.[name]?.[scoreType])) {
            return this.scoreInfo.scores[name][scoreType];
        }
        else {
            tootLogger.trace(`no score available for ${scoreType}/${name}:`, this);
            return 0;
        }
    }
    /**
     * Make an API call to get this toot's URL on the home server instead of on the toot's original server.
     *       this: https://fosstodon.org/@kate/114360290341300577
     *    becomes: https://universeodon.com/@kate@fosstodon.org/114360290578867339
     * @returns {Promise&lt;string>} The home server URL.
     */
    async homeserverURL() {
        const homeURL = `${this.account.homserverURL}/${await this.resolveID()}`;
        tootLogger.debug(`&lt;homeserverURL()> converted '${this.realURL}' to '${homeURL}'`);
        return homeURL;
    }
    /**
     * Return true if the toot should not be filtered out of the feed by the current filters.
     * @param {FeedFilterSettings} filters - The feed filter settings.
     * @returns {boolean}
     */
    isInTimeline(filters) {
        let isOK = Object.values(filters.booleanFilters).every((section) => section.isAllowed(this));
        return isOK &amp;&amp; Object.values(filters.numericFilters).every((filter) => filter.isAllowed(this));
    }
    /**
     * Return false if Toot should be discarded from feed altogether and permanently.
     * @param {mastodon.v2.Filter[]} serverSideFilters - Server-side filters.
     * @returns {boolean}
     */
    isValidForFeed(serverSideFilters) {
        if (this.reblog?.muted || this.muted) {
            tootLogger.trace(`Removing toot from muted account (${this.author.describe()}):`, this);
            return false;
        }
        else if (Date.now() &lt; this.tootedAt.getTime()) {
            // Sometimes there are wonky statuses that are like years in the future so we filter them out.
            tootLogger.warn(`Removing toot with future timestamp:`, this);
            return false;
        }
        else if (this.filtered?.length || this.reblog?.filtered?.length) {
            // The user can configure suppression filters through a Mastodon GUI (webapp or whatever)
            const filterMatches = (this.filtered || []).concat(this.reblog?.filtered || []);
            const filterMatchStr = filterMatches[0].keywordMatches?.join(' ');
            tootLogger.trace(`Removing toot matching server filter (${filterMatchStr}): ${this.describe()}`);
            return false;
        }
        else if (this.tootedAt &lt; (0, time_helpers_1.timelineCutoffAt)()) {
            tootLogger.trace(`Removing toot older than ${(0, time_helpers_1.timelineCutoffAt)()}:`, this.tootedAt);
            return false;
        }
        // Return false if toot matches any server side filters
        return !serverSideFilters.some((filter) => (filter.keywords.some((keyword) => {
            if (this.realToot.containsString(keyword.keyword)) {
                tootLogger.trace(`Removing toot matching manual server side filter (${this.describe()}):`, filter);
                return true;
            }
        })));
    }
    /**
     * Get Status obj for toot from user's home server so the property URLs point to the home server.
     * @returns {Promise&lt;Toot>}
     */
    async resolve() {
        try {
            tootLogger.trace(`Resolving local toot ID for`, this);
            const resolvedToot = await api_1.default.instance.resolveToot(this);
            this.resolvedID = resolvedToot.id; // Cache the resolved ID for future calls
            return resolvedToot;
        }
        catch (error) {
            tootLogger.error(`Error resolving a toot:`, error, `\nThis was the toot:`, this);
            throw error;
        }
    }
    /**
     * Get Status ID for toot from user's home server so the property URLs point to the home server.
     * @returns {Promise&lt;string>}
     */
    async resolveID() {
        this.resolvedID ||= (await this.resolve()).id;
        return this.resolvedID;
    }
    //////////////////////////////
    //     Private methods      //
    //////////////////////////////
    // Replace custome emoji shortcodes (e.g. ":myemoji:") with image tags in a string
    addEmojiHtmlTags(str, fontSize = string_helpers_1.DEFAULT_FONT_SIZE) {
        const emojis = (this.emojis || []).concat(this.account.emojis || []);
        return (0, string_helpers_1.replaceEmojiShortcodesWithImgTags)(str, emojis, fontSize);
    }
    // return MediaAttachmentType objects with type == attachmentType
    attachmentsOfType(attachmentType) {
        return this.realToot.mediaAttachments.filter(attachment => attachment.type == attachmentType);
    }
    // Some properties cannot be repaired and/or set until info about the user is available.
    // Also some properties are very slow - in particular all the tag and trendingLink calcs.
    // isDeepInspect argument is used to determine if we should do the slow calculations or quick ones.
    completeProperties(userData, trendingLinks, trendingTags, source) {
        if (source) {
            this.sources ??= [];
            // TODO: this JUST_MUTING thing is a really ugly hack to allow muting accounts in real time
            if (source != exports.JUST_MUTING &amp;&amp; !this.sources.includes(source)) {
                this.sources?.push(source);
            }
        }
        const isDeepInspect = !source;
        this.muted ||= (this.author.webfingerURI in userData.mutedAccounts);
        this.account.isFollowed ||= (this.account.webfingerURI in userData.followedAccounts);
        if (this.reblog) {
            this.reblog.account.isFollowed ||= (this.reblog.account.webfingerURI in userData.followedAccounts);
        }
        // TODO: We handled muted/followed before checking if complete so we can refresh mutes &amp; follows which sucks
        if (this.isComplete())
            return;
        const toot = this.realToot; // Retoots never have their own tags, etc.
        // containsString() matched way too many toots so we use containsTag() for participated tags
        // TODO: things might be fast enough to try this again
        toot.participatedTags = userData.participatedTags.filter(tag => toot.containsTag(tag)).objs;
        // With all the containsString() calls it takes ~1.1 seconds to build 40 toots
        // Without them it's ~0.1 seconds. In particular the trendingLinks are slow! maybe 90% of that time.
        toot.followedTags = userData.followedTags.filter(tag => toot.containsTag(tag, isDeepInspect)).objs;
        toot.trendingTags = trendingTags.filter(tag => toot.containsTag(tag, isDeepInspect));
        // Only set the completedAt field if isDeepInspect is true  // TODO: might be fast enough to try this again?
        if (isDeepInspect) {
            toot.trendingLinks = trendingLinks.filter(link => link.regex.test(this.contentWithCard()));
            this.completedAt = toot.completedAt = new Date().toISOString(); // Multiple assignmnet!
        }
        else {
            toot.trendingLinks ||= []; // Very slow to calculate so skip it unless isDeepInspect is true
        }
    }
    // Generate a string describing the followed and trending tags in the toot
    containsTagsOfTypeMsg(tagType) {
        let tags = [];
        if (tagType == enums_2.TypeFilterName.FOLLOWED_HASHTAGS) {
            tags = this.followedTags || [];
        }
        else if (tagType == enums_2.TypeFilterName.PARTICIPATED_TAGS) {
            tags = this.participatedTags || [];
        }
        else if (tagType == enums_2.TypeFilterName.TRENDING_TAGS) {
            tags = this.trendingTags || [];
        }
        else {
            tootLogger.warn(`${(0, string_helpers_1.arrowed)('containsTagsOfTypeMsg()')} called with invalid tagType: ${tagType}`);
            return;
        }
        if (!tags.length)
            return;
        const tagTypeStr = (0, change_case_1.capitalCase)(tagType).replace(/ Tag/, " Hashtag");
        return `${tagTypeStr}: ${tags.map(t => `#${t.name}`).join(", ")}`;
    }
    // Return the toot's 'content' field stripped of HTML tags and emojis
    contentString() {
        return (0, string_helpers_1.htmlToText)(this.realToot.contentWithEmojis());
    }
    // Return the toot's content + link description stripped of everything (links, mentions, tags, etc.)
    contentStripped() {
        if (!this.contentCache[TootCacheKey.CONTENT_STRIPPED]) {
            const str = (0, string_helpers_1.removeEmojis)((0, string_helpers_1.removeTags)((0, string_helpers_1.removeLinks)(this.contentWithCard())));
            this.contentCache[TootCacheKey.CONTENT_STRIPPED] = (0, string_helpers_1.collapseWhitespace)((0, string_helpers_1.removeMentions)(str));
        }
        return this.contentCache[TootCacheKey.CONTENT_STRIPPED];
    }
    // Return the content with the card title and description added in parentheses, stripped of diacritics for matching tags
    // cache results for future calls to containsString() and containsTag() etc.
    contentWithCard() {
        if (!this.contentCache[TootCacheKey.CONTENT_WITH_CARD]) {
            const cardContent = [this.card?.title || "", this.card?.description || ""].join(" ").trim();
            const txt = (this.contentString() + (cardContent.length ? ` (${(0, string_helpers_1.htmlToText)(cardContent)})` : "")).trim();
            this.contentCache[TootCacheKey.CONTENT_WITH_CARD] = (0, string_helpers_1.removeDiacritics)(txt);
        }
        return this.contentCache[TootCacheKey.CONTENT_WITH_CARD];
    }
    // Figure out an appropriate language for the toot based on the content.
    determineLanguage() {
        const text = this.contentStripped();
        // if (this.isUsersOwnToot() || text.length &lt; MIN_CHARS_FOR_LANG_DETECT) {
        if (text.length &lt; MIN_CHARS_FOR_LANG_DETECT) {
            this.language ??= config_1.config.locale.defaultLanguage;
            return;
        }
        const langDetectInfo = (0, language_helper_1.detectLanguage)(text);
        const { chosenLanguage, langDetector, tinyLD } = langDetectInfo;
        const langLogObj = { ...langDetectInfo, text, toot: this, tootLanguage: this.language };
        const logTrace = (msg) => repairLogger.trace(`${msg} for "${text}"`, langLogObj);
        // If there's nothing detected log a warning (if text is long enough) and set language to default
        if ((tinyLD.languageAccuracies.length + langDetector.languageAccuracies.length) == 0) {
            if (text.length > (MIN_CHARS_FOR_LANG_DETECT * 2)) {
                repairLogger.warn(`no language detected`, langLogObj);
            }
            this.language ??= config_1.config.locale.defaultLanguage;
            return;
        }
        // If either language detection matches this.language return
        if (this.language &amp;&amp; (tinyLD.chosenLang == this.language || langDetector.chosenLang == this.language)) {
            return;
        }
        // Or if we have successfully detected a language assign it to this.language and return
        if (chosenLanguage) {
            // Don't overwrite "zh-TW" with "zh"
            if (this.language?.startsWith(chosenLanguage)) {
                return;
            }
            else if (this.language &amp;&amp; this.language != exports.UNKNOWN) {
                logTrace(`Using chosenLanguage "${chosenLanguage}" to replace "${this.language}"`);
            }
            this.language = chosenLanguage;
            return;
        }
        if (language_helper_1.FOREIGN_SCRIPTS.has(tinyLD.chosenLang) &amp;&amp; this.language?.startsWith(tinyLD.chosenLang)) {
            logTrace(`Using existing foreign lang "${this.language}" even with low accuracy`);
            return;
        }
        // Prioritize English in edge cases with low tinyLD accuracy but "en" either in toot or in LangDetector result
        if (!tinyLD.isAccurate &amp;&amp; langDetector.isAccurate &amp;&amp; langDetector.chosenLang == language_helper_1.LANGUAGE_NAMES.english) {
            logTrace(`Accepting "en" from langDetector.detectedLang`);
            this.language = language_helper_1.LANGUAGE_NAMES.english;
            return;
        }
        if (this.language) {
            if (text.length > (2 * MIN_CHARS_FOR_LANG_DETECT)) {
                logTrace(`No guess good enough to override language "${this.language}" for "${text}"`);
            }
        }
        else {
            logTrace(`Defaulting language prop to "en"`);
            this.language ??= config_1.config.locale.defaultLanguage;
        }
        // If this is the user's own toot and we have a language set, log it
        // TODO: remove this eventually
        if (this.isUsersOwnToot() &amp;&amp; this.language != config_1.config.locale.defaultLanguage) {
            repairLogger.warn(`User's own toot language set to "${this.language}"`, langLogObj);
        }
    }
    // Returns true if the toot should be re-completed
    isComplete() {
        if (!this.completedAt)
            return false; // If we haven't completed it yet, do it now
        // If we have completed it, check if we need to re-evaluate for newer trending tags, links, etc.
        return (
        // Check if toot was completed long enough ago that we might want to re-evaluate it
        (0, time_helpers_1.ageInMinutes)(this.completedAt) &lt; config_1.config.minTrendingMinutesUntilStale()
            // But not tooted so long ago that there's little chance of new data
            || (0, time_helpers_1.ageInMinutes)(this.createdAt) > config_1.config.toots.completeAfterMinutes);
    }
    // Returns true if this toot is by the fedialgo user
    isUsersOwnToot() {
        const fedialgoUserWebfingerURI = api_1.default.instance.user.webfingerURI;
        if (this.account.webfingerURI == fedialgoUserWebfingerURI)
            return true;
        if (this.reblog &amp;&amp; this.reblog.account.webfingerURI == fedialgoUserWebfingerURI)
            return true;
        return false;
    }
    // Repair toot properties:
    //   - Set toot.application.name to UNKNOWN if missing
    //   - Call determineLanguage() to set the language
    //   - Lowercase all tags
    //   - Repair mediaAttachment types if reparable based on URL file extension
    //   - Repair StatusMention objects for users on home server
    repair() {
        this.application ??= { name: exports.UNKNOWN };
        this.application.name ??= exports.UNKNOWN;
        this.tags.forEach(tag_1.repairTag); // Repair Tags
        this.determineLanguage(); // Determine language
        if (this.reblog) {
            this.trendingRank ||= this.reblog.trendingRank;
            const reblogsByAccts = this.reblogsBy.map((account) => account.webfingerURI);
            if (!reblogsByAccts.includes(this.account.webfingerURI)) {
                this.reblog.reblogsBy.push(this.account);
                this.reblog.reblogsBy = (0, collection_helpers_1.sortObjsByProps)(this.reblog.reblogsBy, ["displayName"], true, true);
            }
        }
        // Check for weird media types
        this.mediaAttachments.forEach((media) => {
            if (media.type == exports.UNKNOWN) {
                const category = (0, string_helpers_1.determineMediaCategory)(media.remoteUrl);
                if (category) {
                    repairLogger.trace(`Repaired broken ${category} attachment in toot:`, this);
                    media.type = category;
                }
                else if (this.uri?.includes(BSKY_BRIDGY) &amp;&amp; media.previewUrl?.endsWith("/small") &amp;&amp; !media.previewRemoteUrl) {
                    // Special handling for Bluesky bridge images
                    repairLogger.debug(`Repairing broken bluesky bridge image attachment in toot:`, this);
                    media.type = enums_1.MediaCategory.IMAGE;
                }
                else {
                    repairLogger.warn(`Unknown media type for URL: '${media.remoteUrl}' for toot:`, this);
                }
            }
            else if (!string_helpers_1.MEDIA_TYPES.includes(media.type)) {
                repairLogger.warn(`Unknown media of type: '${media.type}' for toot:`, this);
            }
            if ((0, string_helpers_1.isEmptyStr)(media?.url)) {
                repairLogger.warn(`Media attachment URL is empty for toot:`, this);
            }
        });
        // Repair StatusMention.acct field for users on the home server by appending @serverDomain
        this.mentions.forEach((mention) => {
            if (mention.acct &amp;&amp; !mention.acct.includes("@")) {
                mention.acct += `@${(0, string_helpers_1.extractDomain)(mention.url)}`;
            }
        });
    }
    ////////////////////////////////
    //       Static methods       //
    ////////////////////////////////
    /**
     * Build array of new Toot objects from an array of Status objects (or Toots).
     * Toots returned are sorted by score and should have most of their properties set correctly.
     * @param {TootLike[]} statuses - Array of status objects or Toots.
     * @param {string} source - The source label for logging.
     * @param {boolean} [skipSort] - If true, don't sort by score and don't remove the user's own toots.
     * @returns {Promise&lt;Toot[]>}
     */
    static async buildToots(statuses, source, skipSort) {
        if (!statuses.length)
            return []; // Avoid the data fetching if we don't to build anything
        const logger = tootLogger.tempLogger(source, `buildToots()`);
        const startedAt = new Date();
        // NOTE: this calls completeToots() with isDeepInspect = false. You must later call it with true
        // to get the full set of properties set on the Toots.
        let toots = await this.completeToots(statuses, logger, source);
        toots = await this.removeInvalidToots(toots, logger);
        toots = Toot.dedupeToots(toots, logger);
        if (!skipSort)
            toots = this.removeUsersOwnToots(toots, logger); // Don't want to remove user's toots from threads
        // Make a first pass at scoring with whatever scorers are ready to score
        await scorer_1.default.scoreToots(toots, false);
        if (!skipSort)
            toots.sort((a, b) => b.score - a.score);
        logger.trace(`${toots.length} toots built in ${(0, time_helpers_1.ageString)(startedAt)}`);
        return toots;
    }
    /**
     * Fetch all the data we need to set dependent properties and set them on the toots.
     * If 'source' arg is provided we set it as the Toot.source prop and avoid doing an isDeepInspect completion.
     * @param {TootLike[]} toots - Array of toots to complete.
     * @param {Logger} logger - Logger for logging.
     * @param {string} [source] - Optional source label.
     * @returns {Promise&lt;Toot[]>}
     */
    static async completeToots(toots, logger, source) {
        logger = logger.tempLogger(`completeToots(${source || ''})`);
        const isDeepInspect = !source;
        const startedAt = new Date();
        const userData = await api_1.default.instance.getUserData();
        const trendingTags = (await mastodon_server_1.default.fediverseTrendingTags()).topObjs();
        const trendingLinks = isDeepInspect ? (await mastodon_server_1.default.fediverseTrendingLinks()) : []; // Skip trending links
        let completeToots = [];
        let tootsToComplete = toots;
        // If isDeepInspect separate toots that need completing bc it's slow to rely on shouldComplete() + batching
        if (isDeepInspect) {
            [completeToots, tootsToComplete] = ((0, collection_helpers_1.split)(toots, (t) => t instanceof Toot &amp;&amp; t.isComplete()));
        }
        const newCompleteToots = await (0, collection_helpers_1.batchMap)(tootsToComplete, async (tootLike) => {
            const toot = (tootLike instanceof Toot ? tootLike : Toot.build(tootLike));
            toot.completeProperties(userData, trendingLinks, trendingTags, source);
            return toot;
        }, {
            batchSize: config_1.config.toots.batchCompleteSize,
            logger,
            sleepBetweenMS: isDeepInspect ? config_1.config.toots.batchCompleteSleepBetweenMS : 0
        });
        const msg = `${toots.length} toots ${(0, time_helpers_1.ageString)(startedAt)}`;
        logger.debug(`${msg} (${newCompleteToots.length} completed, ${completeToots.length} skipped)`);
        return newCompleteToots.concat(completeToots);
    }
    /**
     * Remove dupes by uniquifying on the toot's URI.
     * @param {Toot[]} toots - Array of toots.
     * @param {Logger} [inLogger] - Logger for logging.
     * @returns {Toot[]} Deduped array of toots.
     */
    static dedupeToots(toots, inLogger) {
        inLogger ||= tootLogger;
        const logger = inLogger.tempLogger('dedupeToots()');
        const tootsByURI = (0, collection_helpers_1.groupBy)(toots, toot => toot.realURI);
        // Collect the properties of a single Toot from all the instances of the same URI (we can
        // encounter the same Toot both in the user's feed as well as in a Trending toot list).
        Object.values(tootsByURI).forEach((uriToots) => {
            if (uriToots.length == 1)
                return; // If there's only one toot, nothing to do
            const firstCompleted = uriToots.find(toot => !!toot.realToot.completedAt);
            const firstScoredToot = uriToots.find(toot => !!toot.scoreInfo); // TODO: this is probably wrong
            const firstTrendingRankToot = uriToots.find(toot => !!toot.realToot.trendingRank); // TODO: should probably use most recent toot
            // Deal with array properties that we want to collate
            const uniqFiltered = this.uniqFlatMap(uriToots, "filtered", (f) => f.filter.id);
            const uniqFollowedTags = this.uniqFlatMap(uriToots, "followedTags", (t) => t.name);
            const uniqTrendingLinks = this.uniqFlatMap(uriToots, "trendingLinks", (t) => t.url);
            const uniqTrendingTags = this.uniqFlatMap(uriToots, "trendingTags", (t) => t.name);
            const uniqSources = this.uniqFlatMap(uriToots, "sources", (source) => source);
            // Collate multiple retooters if they exist
            let reblogsBy = this.uniqFlatMap(uriToots, "reblogsBy", (account) => account.webfingerURI);
            reblogsBy = (0, collection_helpers_1.sortObjsByProps)(reblogsBy, ["displayName"], true, true);
            // Collate accounts - reblogs and realToot accounts
            const allAccounts = uriToots.flatMap(t => [t.account].concat(t.reblog ? [t.reblog.account] : []));
            // Helper method to collate the isFollowed property for the accounts
            const isFollowed = (uri) => allAccounts.some((a) => a.isFollowed &amp;&amp; (a.webfingerURI == uri));
            // Counts may increase over time w/repeated fetches so we collate the max
            const propsThatChange = PROPS_THAT_CHANGE.reduce((propValues, propName) => {
                propValues[propName] = Math.max(...uriToots.map(t => t.realToot[propName] || 0));
                return propValues;
            }, {});
            uriToots.forEach((toot) => {
                // propsThatChange are only set on the realToot
                toot.realToot.favouritesCount = propsThatChange.favouritesCount;
                toot.realToot.numTimesShown = propsThatChange.numTimesShown;
                toot.realToot.reblogsCount = propsThatChange.reblogsCount;
                toot.realToot.repliesCount = propsThatChange.repliesCount;
                // Props set on first found
                toot.realToot.completedAt ??= firstCompleted?.completedAt; // DON'T automatically copy to base toot - some fields may need setting later
                toot.realToot.trendingRank ??= firstTrendingRankToot?.trendingRank;
                toot.scoreInfo ??= firstScoredToot?.scoreInfo; // TODO: this is probably wrong... retoot scores could differ but should be corrected
                // Tags + sources + server side filter matches
                toot.realToot.followedTags = uniqFollowedTags;
                toot.realToot.trendingLinks = uniqTrendingLinks;
                toot.realToot.trendingTags = uniqTrendingTags;
                toot.filtered = uniqFiltered;
                toot.sources = uniqSources;
                // Booleans usually only set on the realToot
                toot.realToot.bookmarked = uriToots.some(toot => toot.realToot.bookmarked);
                toot.realToot.favourited = uriToots.some(toot => toot.realToot.favourited);
                toot.realToot.reblogged = uriToots.some(toot => toot.realToot.reblogged);
                toot.account.isFollowed ||= isFollowed(toot.account.webfingerURI);
                toot.muted = uriToots.some(toot => toot.muted); // Liberally set muted on retoots and real toots
                // Reblog props
                if (toot.reblog) {
                    toot.reblog.account.isFollowed ||= isFollowed(toot.reblog.account.webfingerURI);
                    toot.reblog.completedAt ??= firstCompleted?.completedAt;
                    toot.reblog.filtered = uniqFiltered;
                    toot.reblog.reblogsBy = reblogsBy;
                    toot.reblog.sources = uniqSources;
                }
            });
        });
        // Choose the most recent retoot from the group of toots with the same realURI value
        const deduped = Object.values(tootsByURI).map((toots) => {
            const mostRecent = (0, exports.mostRecentToot)(toots);
            // Skip logging this in production
            if (!environment_helpers_1.isProduction &amp;&amp; (0, collection_helpers_1.uniquify)(toots.map(t => t.uri)).length > 1) {
                logger.deep(`deduped ${toots.length} toots to ${mostRecent.describe()}:`, toots);
            }
            return mostRecent;
        });
        logger.logArrayReduction(toots, deduped, "Toot", "duplicate");
        return deduped;
    }
    /**
     * Get rid of toots we never want to see again.
     * @param {Toot[]} toots - Array of toots.
     * @param {Logger} logger - Logger for logging.
     * @returns {Promise&lt;Toot[]>}
     */
    static async removeInvalidToots(toots, logger) {
        const serverSideFilters = (await api_1.default.instance.getServerSideFilters()) || [];
        return (0, collection_helpers_1.filterWithLog)(toots, t => t.isValidForFeed(serverSideFilters), logger, 'invalid', 'Toot');
    }
    /**
     * Get rid of the user's own toots.
     * @param {Toot[]} toots - Array of toots.
     * @param {Logger} logger - Logger for logging.
     * @returns {Toot[]} Array without user's own toots.
     */
    static removeUsersOwnToots(toots, logger) {
        const newToots = toots.filter(toot => !toot.isUsersOwnToot());
        logger.logArrayReduction(toots, newToots, 'Toot', "user's own toots");
        return newToots;
    }
    /**
     * Filter an array of toots down to just the retoots.
     * @param {Toot[]} toots - Array of toots.
     * @returns {Toot[]} Array of retoots.
     */
    static onlyRetoots(toots) {
        return toots.filter(toot => toot.reblog);
    }
    /**
     * Filter an array of toots down to just the replies.
     * @param {Toot[]} toots - Array of toots.
     * @returns {Toot[]} Array of replies.
     */
    static onlyReplies(toots) {
        return toots.filter(toot => toot.inReplyToAccountId);
    }
    /**
     * Return a new array of a toot property collected and uniquified from an array of toots.
     * @template T
     * @param {Toot[]} toots - Array of toots.
     * @param {KeysOfValueType&lt;Toot, any[] | undefined>} property - The property to collect.
     * @param {(elem: T) => string} uniqFxn - Function to get unique key for each element.
     * @returns {T[]} Array of unique property values.
     */
    static uniqFlatMap(toots, property, uniqFxn) {
        const mappedReblogs = toots.flatMap(toot => toot.reblog?.[property] ?? []);
        const mapped = (toots.flatMap(toot => toot[property] ?? [])).concat(mappedReblogs);
        return (0, collection_helpers_1.uniquifyByProp)(mapped, uniqFxn);
    }
}
exports.default = Toot;
__decorate([
    (0, class_transformer_1.Type)(() => account_1.default),
    __metadata("design:type", account_1.default)
], Toot.prototype, "account", void 0);
__decorate([
    (0, class_transformer_1.Type)(() => Toot),
    __metadata("design:type", Object)
], Toot.prototype, "reblog", void 0);
__decorate([
    (0, class_transformer_1.Type)(() => account_1.default),
    __metadata("design:type", Array)
], Toot.prototype, "reblogsBy", void 0);
;
/**
 * Get the Date the toot was created.
 * @param {TootLike} toot - The toot object.
 * @returns {Date}
 */
const tootedAt = (toot) => new Date(toot.createdAt);
exports.tootedAt = tootedAt;
/**
 * Get the earliest toot from a list.
 * @param {StatusList} toots - List of toots.
 * @returns {TootLike | null}
 */
const earliestToot = (toots) => sortByCreatedAt(toots)[0];
exports.earliestToot = earliestToot;
/**
 * Get the most recent toot from a list.
 * @param {StatusList} toots - List of toots.
 * @returns {TootLike | null}
 */
const mostRecentToot = (toots) => sortByCreatedAt(toots).slice(-1)[0];
exports.mostRecentToot = mostRecentToot;
/**
 * Returns array with oldest toot first.
 * @template T
 * @param {T} toots - List of toots.
 * @returns {T}
 */
function sortByCreatedAt(toots) {
    return toots.toSorted((a, b) => (a.createdAt &lt; b.createdAt) ? -1 : 1);
}
exports.sortByCreatedAt = sortByCreatedAt;
;
/**
 * Get the Date of the earliest toot in a list.
 * @param {StatusList} toots - List of toots.
 * @returns {Date | null}
 */
const earliestTootedAt = (toots) => {
    const earliest = (0, exports.earliestToot)(toots);
    return earliest ? (0, exports.tootedAt)(earliest) : null;
};
exports.earliestTootedAt = earliestTootedAt;
/**
 * Get the Date of the most recent toot in a list.
 * @param {StatusList} toots - List of toots.
 * @returns {Date | null}
 */
const mostRecentTootedAt = (toots) => {
    const newest = (0, exports.mostRecentToot)(toots);
    return newest ? (0, exports.tootedAt)(newest) : null;
};
exports.mostRecentTootedAt = mostRecentTootedAt;
//# sourceMappingURL=toot.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Toot.html">Toot</a></li><li><a href="module-collection_helpers.html">collection_helpers</a></li></ul><h3>Classes</h3><ul><li><a href="Account.html">Account</a></li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="MastoApi.html">MastoApi</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="TagList.html">TagList</a></li><li><a href="TheAlgorithm.html">TheAlgorithm</a></li><li><a href="UserData.html">UserData</a></li><li><a href="module-Toot-Toot.html">Toot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#api_1">api_1</a></li><li><a href="global.html#isAccessTokenRevokedError">isAccessTokenRevokedError</a></li><li><a href="global.html#isRateLimitError">isRateLimitError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Jun 09 2025 03:21:55 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>FediAlgo Source: api/obj_with_counts_list.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api/obj_with_counts_list.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BooleanFilterOptionList = void 0;
/**
 * A list of things with a name and a 'numToots' property that can be used
 * somewhat interchangeably as a dictionary or a sorted list.
 * @module ObjWithCountList
 */
const user_data_1 = __importDefault(require("./user_data"));
const math_helper_1 = require("../helpers/math_helper");
const logger_1 = require("../helpers/logger");
const collection_helpers_1 = require("../helpers/collection_helpers");
const string_helpers_1 = require("../helpers/string_helpers");
/**
 * A generic list class for objects with a name and a 'numToots' property.
 * Supports both dictionary and sorted list operations, and provides utility methods
 * for filtering, mapping, counting, and muting/removing items by keywords or server-side filters.
 *
 * @template T extends NamedTootCount
 * @property {number} length - The number of objects in the list.*
 * @property {Logger} logger - Logger instance for this list.
 * @property {Record&lt;string, T>} nameDict - Dictionary mapping object names to objects.
 * @property {ListSource} source - The source of the list (for logging/context).
 * @property {number | undefined} maxNumToots - The maximum numToots value in the list.
 * @property {T[]} objs - The array of objects in the list.
 */
class ObjWithCountList {
    length;
    logger;
    nameDict = {}; // Dict of obj.names to objs
    source;
    get maxNumToots() { return this._maxNumToots; }
    ;
    get objs() { return this._objs; }
    ;
    _maxNumToots; // Cached max numToots value, if it exists
    _objs;
    // Has side effect of mutating the 'tagNames' dict property
    set objs(objs) {
        this._objs = objs;
        this.length = this._objs.length;
        this.nameDict = this.objNameDict();
        this._maxNumToots = this.maxValue("numToots");
    }
    constructor(objs, source) {
        objs.forEach(obj => this.completeObjWithTootCounts(obj));
        this._objs = objs;
        this.length = this._objs.length;
        this.nameDict = this.objNameDict();
        this.source = source;
        this.logger = new logger_1.Logger("ObjWithCountList", source);
    }
    // Add objects we don't already have. This does NOT set the numToots property on incoming objs!
    addObjs(objs) {
        this.objs = [...this.objs, ...objs.filter(obj => !this.nameDict[obj.name])];
    }
    // Remove elements that don't match the predicate(). Returns a new ObjWithCountList object
    filter(predicate) {
        return new ObjWithCountList(this.objs.filter(predicate), this.source);
    }
    /**
     * Returns the object in the list with the given name, or undefined if not found.
     * Name matching is case-insensitive.
     * @param {string} name - The name of the object to retrieve.
     * @returns {T | undefined} The object with the specified name, or undefined if not found.
     */
    getObj(name) {
        return this.nameDict[name.toLowerCase()];
    }
    // Increment numToots for the given name. If no obj with 'name' exists create a new one
    // and call the decorator function on the new function if provided.
    incrementCount(name, newObjDecorator) {
        let option = this.nameDict[name];
        if (!option) {
            option = { name, numToots: 0 };
            this.nameDict[name] = option;
            this.objs.push(option);
            newObjDecorator?.(option);
        }
        option.numToots = (option.numToots || 0) + 1;
        return option;
    }
    // Standard map function that applies a callback to each object in the objs array
    map(callback) {
        return this.objs.map((obj, i) => callback(obj, i));
    }
    // Get the maximum value for a given key across the objs array
    maxValue(propertyName) {
        const values = this.objs.map(obj => obj[propertyName]).filter(n => (0, math_helper_1.isNumber)(n));
        return values.length ? Math.max(...values) : undefined;
    }
    // Returns a dict of tag names to numToots, which is (for now) what is used by BooleanFilter
    nameToNumTootsDict() {
        return this.objs.reduce((dict, tag) => {
            dict[tag.name] = tag.numToots || 0;
            return dict;
        }, {});
    }
    // Populate the objs array by counting the number of times each 'name' (given by propExtractor) appears
    // Resulting BooleanFilterOptions will be decorated with properties returned by propExtractor().
    populateByCountingProps(objs, propExtractor) {
        this.logger.deep(`populateByCountingProps() - Counting properties in ${objs.length} objects...`);
        const options = objs.reduce((optionDict, obj) => {
            const extractedProps = propExtractor(obj);
            optionDict[extractedProps.name] ??= extractedProps;
            optionDict[extractedProps.name].numToots = (optionDict[extractedProps.name].numToots || 0) + 1;
            return optionDict;
        }, {});
        this.objs = Object.values(options);
    }
    // Remove tags that match any of the keywords
    removeKeywords(keywords) {
        keywords = keywords.map(k => (k.startsWith('#') ? k.slice(1) : k).toLowerCase().trim());
        const validObjs = this.objs.filter(tag => !keywords.includes(tag.name));
        this.logger.logArrayReduction(this.objs, validObjs, "Tag", `matching keywords`); //  "${keywords}"`);
        this.objs = validObjs;
    }
    ;
    // Screen a list of hashtags against the user's server side filters, removing any that are muted.
    async removeMutedTags() {
        this.removeKeywords(await user_data_1.default.getMutedKeywords());
    }
    ;
    /**
     * Returns the object in the list with the given name, or undefined if not found.
     * Name matching is case-insensitive.
     * @param {number} [maxObjs] - Optional maximum number of objects to return.
     * @returns {T[]]} Objects sorted by numAccounts if it exists, otherwise numToots, then by name
     */
    topObjs(maxObjs) {
        const sortBy = (this.objs.every(t => t.numAccounts) ? "numAccounts" : "numToots");
        const sortByAndName = [sortBy, "name"];
        this.objs = (0, collection_helpers_1.sortObjsByProps)(Object.values(this.objs), sortByAndName, [false, true]);
        return maxObjs ? this.objs.slice(0, maxObjs) : this.objs;
    }
    // Lowercase the name and set the regex property if it doesn't exist.
    completeObjWithTootCounts(obj) {
        obj.name = obj.name.toLowerCase();
        obj.regex ||= (0, string_helpers_1.wordRegex)(obj.name);
    }
    ;
    // Return a dictionary of tag names to tags
    objNameDict() {
        return this.objs.reduce((objNames, obj) => {
            objNames[obj.name] = obj;
            return objNames;
        }, {});
    }
}
exports.default = ObjWithCountList;
;
/**
 * Special case of ObjWithCountList for BooleanFilterOption objects.
 * @extends {ObjWithCountList}
 */
class BooleanFilterOptionList extends ObjWithCountList {
}
exports.BooleanFilterOptionList = BooleanFilterOptionList;
;
//# sourceMappingURL=obj_with_counts_list.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-ObjWithCountList.html">ObjWithCountList</a></li><li><a href="module-Toot.html">Toot</a></li><li><a href="module-collection_helpers.html">collection_helpers</a></li></ul><h3>Classes</h3><ul><li><a href="Account.html">Account</a></li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="MastoApi.html">MastoApi</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="TheAlgorithm.html">TheAlgorithm</a></li><li><a href="UserData.html">UserData</a></li><li><a href="module-ObjWithCountList-BooleanFilterOptionList.html">BooleanFilterOptionList</a></li><li><a href="module-ObjWithCountList-ObjWithCountList.html">ObjWithCountList</a></li><li><a href="module-ObjWithCountList-TagList.html">TagList</a></li><li><a href="module-Toot-Toot.html">Toot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#api_1">api_1</a></li><li><a href="global.html#isAccessTokenRevokedError">isAccessTokenRevokedError</a></li><li><a href="global.html#isRateLimitError">isRateLimitError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Jun 09 2025 04:07:14 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

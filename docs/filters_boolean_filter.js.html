<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>FediAlgo Source: filters/boolean_filter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: filters/boolean_filter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TYPE_FILTERS = exports.isTypeFilterName = void 0;
/**
 * Feed filtering information related to a single criterion on which toots
 * can be filtered inclusively or exclusively based on an array of strings
 * (e.g. language, hashtag, type of toot).
 */
const api_1 = __importDefault(require("../api/api"));
const mastodon_server_1 = __importDefault(require("../api/mastodon_server"));
const obj_with_counts_list_1 = require("../api/obj_with_counts_list");
const toot_filter_1 = __importDefault(require("./toot_filter"));
const enums_1 = require("../enums");
const string_helpers_1 = require("../helpers/string_helpers");
const config_1 = require("../config");
const collection_helpers_1 = require("../helpers/collection_helpers");
const SOURCE_FILTER_DESCRIPTION = "Choose what kind of toots are in your feed";
const isTypeFilterName = (value) => (0, collection_helpers_1.isValueInStringEnum)(enums_1.TypeFilterName)(value);
exports.isTypeFilterName = isTypeFilterName;
// Type-based filters for toots. Defining a new filter just requires adding a new TypeFilterName
// and a function that matches the toot.
exports.TYPE_FILTERS = {
    [enums_1.TypeFilterName.AUDIO]: (toot) => !!toot.realToot.audioAttachments?.length,
    [enums_1.TypeFilterName.BOT]: (toot) => !!(toot.account.bot || toot.reblog?.account.bot),
    [enums_1.TypeFilterName.DIRECT_MESSAGE]: (toot) => toot.isDM,
    [enums_1.TypeFilterName.FOLLOWED_ACCOUNTS]: (toot) => !!(toot.account.isFollowed || toot.reblog?.account.isFollowed),
    [enums_1.TypeFilterName.FOLLOWED_HASHTAGS]: (toot) => !!toot.realToot.followedTags?.length,
    [enums_1.TypeFilterName.IMAGES]: (toot) => !!toot.realToot.imageAttachments?.length,
    [enums_1.TypeFilterName.LINKS]: (toot) => !!(toot.realToot.card || toot.realToot.trendingLinks?.length),
    [enums_1.TypeFilterName.MENTIONS]: (toot) => toot.containsUserMention(),
    [enums_1.TypeFilterName.POLLS]: (toot) => !!toot.realToot.poll,
    [enums_1.TypeFilterName.PARTICIPATED_TAGS]: (toot) => !!toot.realToot.participatedTags?.length,
    [enums_1.TypeFilterName.PRIVATE]: (toot) => !!toot.realToot.isPrivate,
    [enums_1.TypeFilterName.REPLIES]: (toot) => !!toot.realToot.inReplyToId,
    [enums_1.TypeFilterName.RETOOTS]: (toot) => !!toot.reblog,
    [enums_1.TypeFilterName.SENSITIVE]: (toot) => !!toot.realToot.sensitive,
    [enums_1.TypeFilterName.SPOILERED]: (toot) => !!toot.realToot.spoilerText,
    [enums_1.TypeFilterName.TRENDING_LINKS]: (toot) => !!toot.realToot.trendingLinks?.length,
    [enums_1.TypeFilterName.TRENDING_TAGS]: (toot) => !!toot.realToot.trendingTags?.length,
    [enums_1.TypeFilterName.TRENDING_TOOTS]: (toot) => !!toot.realToot.trendingRank,
    [enums_1.TypeFilterName.VIDEOS]: (toot) => !!toot.realToot.videoAttachments?.length,
};
// Matchers for each BooleanFilterName.
const TOOT_MATCHERS = {
    [enums_1.BooleanFilterName.APP]: (toot, selectedOptions) => {
        return selectedOptions.includes(toot.realToot.application?.name);
    },
    [enums_1.BooleanFilterName.HASHTAG]: (toot, selectedOptions) => {
        return !!selectedOptions.find((v) => toot.realToot.containsString(v));
    },
    [enums_1.BooleanFilterName.LANGUAGE]: (toot, selectedOptions) => {
        return selectedOptions.includes(toot.realToot.language || config_1.config.locale.defaultLanguage);
    },
    [enums_1.BooleanFilterName.TYPE]: (toot, selectedOptions) => {
        return selectedOptions.some((v) => exports.TYPE_FILTERS[v](toot));
    },
    [enums_1.BooleanFilterName.USER]: (toot, selectedOptions) => {
        return selectedOptions.includes(toot.realToot.account.webfingerURI);
    },
};
;
/**
 * BooleanFilter for filtering toots by boolean criteria (e.g. language, hashtag, type).
 * @extends TootFilter
 */
class BooleanFilter extends toot_filter_1.default {
    /**
     * Which options are selected for use in the filter.
     * @type {string[]}
     */
    selectedOptions;
    /**
     * The filter title/category.
     * @type {BooleanFilterName}
     */
    title;
    /**
     * Get the current options list.
     * @returns {BooleanFilterOptionList}
     */
    get options() { return this._options; }
    ;
    _options;
    /**
     * Set the options list and remove invalid selected options.
     * @param {BooleanFilterOptionList} optionList
     */
    set options(optionList) {
        this._options = optionList;
        this.selectedOptions = this.selectedOptions.filter((v) => !optionList.getObj(v));
    }
    constructor({ title, invertSelection, selectedOptions }) {
        let optionInfo = new obj_with_counts_list_1.BooleanFilterOptionList([], title);
        let description;
        if (title == enums_1.BooleanFilterName.TYPE) {
            description = SOURCE_FILTER_DESCRIPTION;
        }
        else {
            const descriptionWord = title == enums_1.BooleanFilterName.HASHTAG ? "including" : "from";
            description = `Show only toots ${descriptionWord} these ${title}s`;
        }
        super({ description, invertSelection, title });
        this._options = optionInfo;
        this.title = title;
        this.selectedOptions = selectedOptions ?? [];
    }
    /**
     * Return true if the toot matches the filter.
     * @param {Toot} toot - The toot to check.
     * @returns {boolean}
     */
    isAllowed(toot) {
        if (!this.selectedOptions.length)
            return true; // If there's no selectedOptions allow everything
        const isMatched = TOOT_MATCHERS[this.title](toot, this.selectedOptions);
        return this.invertSelection ? !isMatched : isMatched;
    }
    /**
     * Return true if the option is in selectedOptions.
     * @param {string} optionName - The option name.
     * @returns {boolean}
     */
    isOptionEnabled(optionName) {
        return this.selectedOptions.includes(optionName);
    }
    /**
     * Return only options that have at least minToots or are in selectedOptions.
     * @param {BooleanFilterOption[]} options - The options to filter.
     * @param {number} [minToots=0] - Minimum number of toots.
     * @returns {BooleanFilterOptionList}
     */
    optionListWithMinToots(options, minToots = 0) {
        options = options.filter(opt => (opt.numToots || 0) >= minToots || this.isOptionEnabled(opt.name));
        return new obj_with_counts_list_1.BooleanFilterOptionList(options, this.title);
    }
    /**
     * Return options sorted by name, filtered by minToots (selected options are always included).
     * @param {number} [minToots=0] - Minimum number of toots.
     * @returns {BooleanFilterOptionList}
     */
    optionsSortedByName(minToots = 0) {
        let options = this.options.objs.toSorted((a, b) => (0, string_helpers_1.compareStr)(a.displayName || a.name, b.displayName || b.name));
        return this.optionListWithMinToots(options, minToots);
    }
    /**
     * Return options sorted by numToots, filtered by minToots.
     * @param {number} [minToots=0] - Minimum number of toots.
     * @returns {BooleanFilterOptionList}
     */
    optionsSortedByValue(minToots = 0) {
        return this.optionListWithMinToots(this.options.topObjs(), minToots);
    }
    /**
     * Add or remove an option from the filter.
     * @param {string} optionName - The option name.
     * @param {boolean} isSelected - If true, add the option; if false, remove it.
     */
    updateOption(optionName, isSelected) {
        this.logger.debug(`Updating options for ${this.title} with ${optionName} and ${isSelected}`);
        if (isSelected &amp;&amp; !this.isOptionEnabled(optionName)) {
            this.selectedOptions.push(optionName);
        }
        else {
            if (!this.isOptionEnabled(optionName)) {
                this.logger.warn(`Tried to remove ${optionName} from ${this.title} but it wasn't there`);
                return;
            }
            this.selectedOptions.splice(this.selectedOptions.indexOf(optionName), 1);
        }
        // Remove duplicates; build new Array object to trigger useMemo() in Demo App // TODO: not great
        this.selectedOptions = [...new Set(this.selectedOptions)];
    }
    /**
     * Required for serialization of settings to local storage.
     * @returns {BooleanFilterArgs}
     */
    toArgs() {
        const filterArgs = super.toArgs();
        filterArgs.selectedOptions = this.selectedOptions;
        return filterArgs;
    }
    /**
     * Collate all the data sources that are used to populate properties of the same name for each BooleanFilterOption.
     * Note this won't be completely up to date but should be good enough for most purposes.
     * TODO: currently unused
     * @returns {Promise&lt;FilterOptionDataSources>}
     */
    static async filterOptionDataSources() {
        const userData = await api_1.default.instance.getUserData();
        return {
            [enums_1.BooleanFilterName.LANGUAGE]: userData.languagesPostedIn,
            [enums_1.ScoreName.FAVOURITED_ACCOUNTS]: userData.favouriteAccounts,
            [enums_1.TagTootsCacheKey.FAVOURITED_TAG_TOOTS]: userData.favouritedTags,
            [enums_1.TagTootsCacheKey.PARTICIPATED_TAG_TOOTS]: userData.participatedTags,
            [enums_1.TagTootsCacheKey.TRENDING_TAG_TOOTS]: await mastodon_server_1.default.fediverseTrendingTags(),
        };
    }
    /**
     * Checks if a given property name is a valid numeric filter name.
     * @param {string} name - The property name to check.
     * @returns {boolean} True if the name is a filterable numeric property.
     */
    static isValidTitle(name) {
        return (0, collection_helpers_1.isValueInStringEnum)(enums_1.BooleanFilterName)(name);
    }
}
exports.default = BooleanFilter;
;
//# sourceMappingURL=boolean_filter.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-ObjWithCountList.html">ObjWithCountList</a></li><li><a href="module-Toot.html">Toot</a></li><li><a href="module-collection_helpers.html">collection_helpers</a></li></ul><h3>Classes</h3><ul><li><a href="Account.html">Account</a></li><li><a href="BooleanFilter.html">BooleanFilter</a></li><li><a href="MastoApi.html">MastoApi</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="TheAlgorithm.html">TheAlgorithm</a></li><li><a href="UserData.html">UserData</a></li><li><a href="module-ObjWithCountList-BooleanFilterOptionList.html">BooleanFilterOptionList</a></li><li><a href="module-ObjWithCountList-ObjWithCountList.html">ObjWithCountList</a></li><li><a href="module-ObjWithCountList-TagList.html">TagList</a></li><li><a href="module-Toot-Toot.html">Toot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#api_1">api_1</a></li><li><a href="global.html#isAccessTokenRevokedError">isAccessTokenRevokedError</a></li><li><a href="global.html#isRateLimitError">isRateLimitError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Jun 09 2025 03:56:03 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

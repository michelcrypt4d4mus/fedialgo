<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>FediAlgo Source: helpers/collection_helpers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: helpers/collection_helpers.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipPromises = exports.zipArrays = exports.uniquifyByProp = exports.uniquify = exports.truncateToConfiguredLength = exports.transformKeys = exports.swapKeysAndValues = exports.sumValues = exports.sumArray = exports.subtractConstant = exports.split = exports.sortObjsByCreatedAt = exports.sortObjsByProps = exports.sortKeysByValue = exports.shuffle = exports.removeKeys = exports.reduceToCounts = exports.makePercentileChunks = exports.makeChunks = exports.keyByProperty = exports.keyById = exports.isValueInStringEnum = exports.decrementCount = exports.incrementCount = exports.groupBy = exports.getPromiseResults = exports.findMinMaxId = exports.filterWithLog = exports.divideDicts = exports.countValues = exports.computeMinMax = exports.checkUniqueIDs = exports.batchMap = exports.average = exports.asOptionalArray = exports.atLeastValues = exports.addDicts = void 0;
/**
 * Various helper methods for dealing with collections (arrays, objects, etc.)
 * @module collection_helpers
 */
const chunk_1 = __importDefault(require("lodash/chunk"));
const string_helpers_1 = require("./string_helpers");
const config_1 = require("../config");
const api_1 = require("../api/api");
const math_helper_1 = require("./math_helper");
const logger_1 = require("./logger");
const time_helpers_1 = require("./time_helpers");
const BATCH_MAP = "batchMap()";
/**
 * Adds up an arbitrary number of StringNumberDicts, returning a new dict.
 * @param {...StringNumberDict[]} dicts - Dictionaries to sum.
 * @returns {StringNumberDict} The summed dictionary.
 */
function addDicts(...dicts) {
    const sumDict = {};
    const keys = new Set(dicts.map((dict => Object.keys(dict))).flat());
    keys.forEach((k) => {
        sumDict[k] = sumArray(dicts.map((d) => d[k] || 0));
    });
    return sumDict;
}
exports.addDicts = addDicts;
;
/**
 * Returns a new object with only the key/value pairs that have a value greater than minValue.
 * @param {StringNumberDict} obj - The input dictionary.
 * @param {number} minValue - The minimum value to include.
 * @returns {StringNumberDict} The filtered dictionary.
 */
function atLeastValues(obj, minValue) {
    return Object.fromEntries(Object.entries(obj).filter(([_k, v]) => v > minValue));
}
exports.atLeastValues = atLeastValues;
;
/**
 * Returns an array containing the value if defined, otherwise an empty array.
 * @template T
 * @param {T | undefined | null} value - The value to wrap.
 * @returns {[T] | []} The optional array.
 */
function asOptionalArray(value) {
    return (0, string_helpers_1.isNull)(value) ? [] : [value];
}
exports.asOptionalArray = asOptionalArray;
;
/**
 * Calculates the average of an array of numbers, ignoring null/undefined completely.
 * @param {number[]} values - The array of numbers.
 * @returns {number} The average, or NaN if the array is empty.
 */
function average(values) {
    values = values.filter(math_helper_1.isNumber);
    if (values.length == 0)
        return NaN;
    return values.reduce((a, b) => a + b, 0) / values.length;
}
exports.average = average;
;
/**
 * Processes an array asynchronously in batches.
 * @template T
 * @param {T[]} array - The array to process.
 * @param {(e: T) => Promise&lt;any>} fxn - The async function to apply.
 * @param {object} [options] - Batch options.
 * @param {number} [options.batchSize] - Batch size.
 * @param {Logger} [options.logger] - Logger instance.
 * @param {number} [options.sleepBetweenMS] - Sleep between batches in ms.
 * @returns {Promise&lt;any[]>} The results of mapping items with fxn().
 */
async function batchMap(array, fxn, options) {
    let { batchSize, logger, sleepBetweenMS } = (options || {});
    logger = logger ? logger.tempLogger(BATCH_MAP) : new logger_1.Logger(BATCH_MAP);
    const chunkSize = batchSize || config_1.config.scoring.scoringBatchSize;
    const chunks = makeChunks(array, { chunkSize, logger });
    let results = [];
    for (let i = 0; i &lt; chunks.length; i++) {
        const chunk = chunks[i];
        const newResults = await Promise.all(chunk.map(fxn));
        if (newResults.filter(Boolean).length)
            results = [...results, ...newResults]; // Only append non-null results
        if (sleepBetweenMS &amp;&amp; (i &lt; (chunks.length - 1))) {
            logger.debug(`${(i + 1) * chunkSize} of ${array.length}, sleeping ${sleepBetweenMS}ms`);
            await (0, time_helpers_1.sleep)(sleepBetweenMS);
        }
    }
    ;
    return results;
}
exports.batchMap = batchMap;
;
/**
 * Checks if the elements of an array have unique IDs and logs a warning if not.
 * @param {MastodonObjWithID[]} array - Array of objects with IDs.
 * @param {ApiCacheKey} label - Label for logging.
 */
function checkUniqueIDs(array, label) {
    const logPrefix = `[${label}]`;
    const objsByID = groupBy(array, (e) => e.id);
    const uniqueIDs = Object.keys(objsByID);
    if (uniqueIDs.length != array.length) {
        console.warn(`${logPrefix} ${array.length} objs only have ${uniqueIDs.length} unique IDs!`, objsByID);
    }
}
exports.checkUniqueIDs = checkUniqueIDs;
;
/**
 * Computes the minimum and maximum values from an array using a value function.
 * @template T
 * @param {T[]} array - The array to process.
 * @param {(value: T) => number | undefined} valueFxn - Function to extract value.
 * @returns {MinMax | null} The min and max values, or null if array is empty.
 */
function computeMinMax(array, valueFxn) {
    if (array.length == 0)
        return null;
    return array.reduce((minMax, obj) => {
        const value = valueFxn(obj);
        if (value) {
            if (value &lt; minMax.min)
                minMax.min = value;
            if (value > minMax.max)
                minMax.max = value;
        }
        return minMax;
    }, { min: Number.MAX_VALUE, max: Number.MIN_VALUE });
}
exports.computeMinMax = computeMinMax;
;
/**
 * Returns a dictionary keyed by the result of getKey() with the count of each key.
 * @template T
 * @param {T[]} items - The items to count.
 * @param {(item: T) => string | null | undefined} [getKey] - Function to get key.
 * @param {boolean} [countNulls] - Whether to count null keys.
 * @returns {StringNumberDict} The counts dictionary.
 */
function countValues(items, getKey = (item) => item, countNulls) {
    return items.reduce((counts, item) => {
        const key = getKey(item);
        return ((0, string_helpers_1.isNull)(key) &amp;&amp; !countNulls) ? counts : incrementCount(counts, key);
    }, {});
}
exports.countValues = countValues;
;
/**
 * Divides the values of dict1 by the values of dict2, returning a new dict.
 * @param {StringNumberDict} dict1 - Numerator dictionary.
 * @param {StringNumberDict} dict2 - Denominator dictionary.
 * @returns {StringNumberDict} The result dictionary.
 */
function divideDicts(dict1, dict2) {
    const result = {};
    const logger = new logger_1.Logger("divideDicts()");
    Object.keys(dict1).forEach((key) => {
        if (dict2[key]) {
            result[key] = dict1[key] / dict2[key];
        }
        else {
            logger.warn(`divideDicts() - key "${key}" had value "${dict2[key]}", skipping division`);
            result[key] = 0;
        }
    });
    return result;
}
exports.divideDicts = divideDicts;
;
/**
 * Filters an array and logs the number of elements removed.
 * @template T
 * @param {T[]} array - The array to filter.
 * @param {(value: T) => boolean} filterFxn - The filter function.
 * @param {Logger} logger - Logger instance.
 * @param {string} reason - Reason for filtering.
 * @param {string} [objType] - Object type for logging.
 * @returns {T[]} The filtered array.
 */
function filterWithLog(array, filterFxn, logger, reason, // Describe why things were filtered
objType) {
    const filtered = array.filter(filterFxn);
    logger.logArrayReduction(array, filtered, objType || "object", reason);
    return filtered;
}
exports.filterWithLog = filterWithLog;
;
/**
 * Finds the minimum and maximum 'id' property in an array of objects that have an 'id' property.
 * Find the minimum 'id' property in an array of objects that have an 'id' property.
 * TODO: Note that this isn't always safe to use - there can be outliers in the data that result in
 * the minimum ID in a set of toots being wildly out of step with the rest of the IDs.
 * If that happens trying to use the min ID as the maxId param for a fetch will fail (no results).
 * This is an unfixable server side problem that we used to work around with this:
 *
 * static findMinIdForMaxIdParam(toots: Toot[]): string | null {
 *     if (toots.length == 0) return null;
 *     const idx = Math.min(toots.length - 1, MAX_ID_IDX);
 *     return sortByCreatedAt(toots)[idx].id;
 * }
 * @param {MastodonObjWithID[]} array - Array of objects with IDs.
 * @returns {MinMaxID | null} The min and max IDs, or null if invalid.
 */
function findMinMaxId(array) {
    if (!array?.length) {
        console.warn(`[findMinMaxId()] called with 0 length array:`, array);
        return null;
    }
    const idVals = array.map(e => e.id);
    const isNumberArray = idVals.every(math_helper_1.isNumberOrNumberString);
    if (idVals.some((id) => id === null || id === undefined)) {
        console.warn(`[findMinMaxId()] called with null IDs:`, idVals);
        return null;
    }
    // IDs are presented as strings but are usually numbers
    const sortedIDs = idVals.toSorted((a, b) => {
        a = a.toString();
        b = b.toString();
        if (isNumberArray) {
            return parseFloat(a) - parseFloat(b);
        }
        else {
            return a > b ? 1 : -1;
        }
    });
    return {
        min: sortedIDs[0].toString(),
        max: sortedIDs.slice(-1)[0].toString()
    };
}
exports.findMinMaxId = findMinMaxId;
;
/**
 * Collates the fulfilled and rejected results from Promise.allSettled() into an easier to handle format.
 * @template T
 * @param {Promise&lt;T>[]} promises - Array of promises.
 * @returns {Promise&lt;PromisesResults&lt;T>>} The results object.
 */
async function getPromiseResults(promises) {
    const results = await Promise.allSettled(promises);
    return {
        fulfilled: results.filter(r => r.status == "fulfilled").map(r => r.value),
        rejectedReasons: results.filter(r => r.status == "rejected").map(r => r.reason),
    };
}
exports.getPromiseResults = getPromiseResults;
;
/**
 * Groups an array by the result of makeKey().
 * TODO: Standard library Object.groupBy() requires some tsconfig setting that i don't understand
 * @template T
 * @param {T[]} array - The array to group.
 * @param {(item: T) => string} makeKey - Function to get group key.
 * @returns {Record&lt;string, T[]>} The grouped object.
 */
function groupBy(array, makeKey) {
    return array.reduce((grouped, item) => {
        const group = makeKey(item);
        grouped[group] ||= [];
        grouped[group].push(item);
        return grouped;
    }, {});
}
exports.groupBy = groupBy;
;
/**
 * Increments the count for a key in a dictionary by 'increment'.
 * @param {StringNumberDict} counts - The counts dictionary.
 * @param {CountKey | null} [k] - The key to increment.
 * @param {number} [increment=1] - The increment amount.
 * @returns {StringNumberDict} The updated dictionary.
 */
function incrementCount(counts, k, increment = 1) {
    k = k ?? "unknown";
    counts[k] = (counts[k] || 0) + increment;
    return counts;
}
exports.incrementCount = incrementCount;
;
/**
 * Return true if the object is a non-null object (not an array, function, etc.).
 * @param {unknown} obj - The object to check.
 * @returns {boolean} True if it's a non-null object
 */
function isRecord(obj) {
    return typeof obj === "object" &amp;&amp; obj !== null &amp;&amp; obj.constructor.name === "Object";
}
;
/**
 * Decrements the count for a key in a dictionary.
 * @param {StringNumberDict} counts - The counts dictionary.
 * @param {CountKey | null} [k] - The key to decrement.
 * @param {number} [increment=1] - The decrement amount.
 * @returns {StringNumberDict} The updated dictionary.
 */
function decrementCount(counts, k, increment = 1) {
    return incrementCount(counts, k, -1 * increment);
}
exports.decrementCount = decrementCount;
;
/**
 * Generate a function to check if a value exists in a string enum.
 * @template E
 * @param {Record&lt;string, E>} strEnum - The enum object.
 * @returns {(value: string) => value is E} The checker function.
 */
function isValueInStringEnum(strEnum) {
    const enumValues = new Set(Object.values(strEnum));
    return (value) => enumValues.has(value);
}
exports.isValueInStringEnum = isValueInStringEnum;
;
/**
 * Builds a dictionary from an array keyed by id.
 * @template T
 * @param {T[]} array - Array of objects with id property.
 * @returns {Record&lt;string, T>} The keyed dictionary.
 */
function keyById(array) {
    return keyByProperty(array, obj => obj.id);
}
exports.keyById = keyById;
;
/**
 * Builds a dictionary from an array keyed by a property.
 * @template T
 * @param {T[]} array - Array of objects.
 * @param {(value: T) => string} keyFxn - Function to get key.
 * @returns {Record&lt;string, T>} The keyed dictionary.
 */
function keyByProperty(array, keyFxn) {
    return array.reduce((keyedDict, obj) => {
        keyedDict[keyFxn(obj)] = obj;
        return keyedDict;
    }, {});
}
exports.keyByProperty = keyByProperty;
;
/**
 * Splits an array into chunks of a given size or number of chunks.
 * @template T
 * @param {T[]} array - The array to chunk.
 * @param {object} options - Chunk options.
 * @param {number} [options.chunkSize] - Size of each chunk.
 * @param {Logger} [options.logger] - Logger instance.
 * @param {number} [options.numChunks] - Number of chunks.
 * @returns {T[][]} The array of chunks.
 */
function makeChunks(array, options) {
    let { chunkSize, logger, numChunks } = options;
    if ((numChunks &amp;&amp; chunkSize) || (!numChunks &amp;&amp; !chunkSize)) {
        throw new Error(`${logger?.logPrefix || 'makeChunks'} requires numChunks OR chunkSize. options=${JSON.stringify(options)}`);
    }
    chunkSize = numChunks ? Math.ceil(array.length / numChunks) : chunkSize;
    return (0, chunk_1.default)(array, chunkSize);
}
exports.makeChunks = makeChunks;
;
/**
 * Sorts an array by a function and divides into numPercentile chunks.
 * @template T
 * @param {T[]} array - The array to sort and chunk.
 * @param {(element: T) => number | undefined} fxn - Function to get value.
 * @param {number} numPercentiles - Number of percentiles.
 * @returns {T[][]} The percentile chunks.
 */
function makePercentileChunks(array, fxn, numPercentiles) {
    const sortedArray = array.toSorted((a, b) => (fxn(a) ?? 0) - (fxn(b) ?? 0));
    return makeChunks(sortedArray, { numChunks: numPercentiles });
}
exports.makePercentileChunks = makePercentileChunks;
;
/**
 * Reduces an array to a StringNumberDict using an update function.
 * @template T
 * @param {T[]} objs - The array to reduce.
 * @param {(accumulator: StringNumberDict, obj: T) => void} updateCounts - Update function.
 * @returns {StringNumberDict} The reduced dictionary.
 */
function reduceToCounts(objs, updateCounts) {
    return objs.reduce((counts, obj) => {
        updateCounts(counts, obj);
        return counts;
    }, {});
}
exports.reduceToCounts = reduceToCounts;
;
/**
 * Removes keys from an object if their value is null or in keysToRemove array.
 * @template T
 * @template K
 * @param {T} obj - The object to clean.
 * @param {K[]} [keysToRemove] - Keys to remove.
 * @param {K[]} [keysToRemoveIfFalse] - Keys to remove if value is false.
 * @returns {Partial&lt;T>} The cleaned object.
 */
function removeKeys(obj, keysToRemove, keysToRemoveIfFalse) {
    const copy = { ...obj };
    Object.keys(copy).forEach((k) => {
        const key = k;
        if ((keysToRemove || []).includes(key) || copy[key] === null || copy[key] === undefined) {
            delete copy[key];
        }
        else if ((keysToRemoveIfFalse || []).includes(key) &amp;&amp; copy[key] === false) {
            delete copy[key];
        }
    });
    return copy;
}
exports.removeKeys = removeKeys;
;
/**
 * Randomizes the order of an array.
 * @template T
 * @param {T[]} array - The array to shuffle.
 * @returns {T[]} The shuffled array.
 */
function shuffle(array) {
    const sortRandom = (a, b) => (0, string_helpers_1.hashObject)(a).localeCompare((0, string_helpers_1.hashObject)(b));
    return array.toSorted(sortRandom);
}
exports.shuffle = shuffle;
;
/**
 * Sorts the keys of a dictionary by their values in descending order.
 * @param {StringNumberDict} dict - The dictionary to sort.
 * @returns {string[]} The sorted keys.
 */
function sortKeysByValue(dict) {
    return Object.keys(dict).sort((a, b) => {
        const aVal = dict[a] || 0;
        const bVal = dict[b] || 0;
        if (aVal == bVal) {
            return (0, string_helpers_1.compareStr)(a, b);
        }
        else {
            return bVal - aVal;
        }
    });
}
exports.sortKeysByValue = sortKeysByValue;
;
/**
 * Sorts an array of objects by one or two properties.
 * @template T
 * @param {T[]} array - The array to sort.
 * @param {keyof T | (keyof T)[]} prop - Property or properties to sort by.
 * @param {boolean | boolean[]} [ascending] - Sort order(s).
 * @param {boolean} [ignoreCase] - Ignore case for string properties.
 * @returns {T[]} The sorted array.
 */
function sortObjsByProps(array, prop, ascending, ignoreCase) {
    ascending ||= false;
    const props = Array.isArray(prop) ? prop : [prop];
    const ascendings = Array.isArray(ascending) ? ascending : [ascending];
    if (props.length > 2)
        throw new Error("sortObjsByProps() only supports 2 properties for sorting for now");
    return array.toSorted((a, b) => {
        let aVal = a[props[0]];
        let bVal = b[props[0]];
        let ascending = ascendings[0];
        if (ignoreCase &amp;&amp; typeof aVal == "string" &amp;&amp; typeof bVal == "string") {
            aVal = aVal.toLowerCase();
            bVal = bVal.toLowerCase();
        }
        if (aVal &lt; bVal)
            return ascending ? -1 : 1;
        if (aVal > bVal)
            return ascending ? 1 : -1;
        if (props.length == 1)
            return 0;
        // Compare second property
        aVal = a[props[1]];
        bVal = b[props[1]];
        ascending = ascendings.length > 1 ? ascendings[1] : ascendings[1];
        if (ignoreCase &amp;&amp; typeof aVal == "string" &amp;&amp; typeof bVal == "string") {
            aVal = aVal.toLowerCase();
            bVal = bVal.toLowerCase();
        }
        if (aVal &lt; bVal)
            return ascending ? -1 : 1;
        if (aVal > bVal)
            return ascending ? 1 : -1;
        return 0;
    });
}
exports.sortObjsByProps = sortObjsByProps;
;
/**
 * Sorts an array of objects by the createdAt property.
 * @template T
 * @param {T[]} array - The array to sort.
 * @returns {T[]} The sorted array.
 */
function sortObjsByCreatedAt(array) {
    return sortObjsByProps(arguments[0], "createdAt");
}
exports.sortObjsByCreatedAt = sortObjsByCreatedAt;
;
/**
 * Splits an array into two arrays based on a condition.
 * @template T
 * @param {T[]} array - The array to split.
 * @param {(element: T) => boolean} condition - The condition function.
 * @returns {[T[], T[]]} The two arrays.
 */
function split(array, condition) {
    return [
        array.filter((element) => condition(element)),
        array.filter((element) => !condition(element)),
    ];
}
exports.split = split;
;
/**
 * Subtracts a constant from all values in a dictionary.
 * @param {StringNumberDict} dict - The dictionary.
 * @param {number} constant - The constant to subtract.
 * @returns {StringNumberDict} The updated dictionary.
 */
function subtractConstant(dict, constant) {
    return Object.fromEntries(Object.entries(dict).map(([k, v]) => [k, v - constant]));
}
exports.subtractConstant = subtractConstant;
;
/**
 * Sums the elements of an array, treating null/undefined as 0.
 * @param {(number | null | undefined)[]} arr - The array to sum.
 * @returns {number} The sum.
 */
function sumArray(arr) {
    const numArray = arr.map((x) => (x ?? 0));
    return numArray.reduce((a, b) => a + b, 0);
}
exports.sumArray = sumArray;
;
/**
 * Sums the values of a dictionary.
 * @param {StringNumberDict | Weights} obj - The dictionary.
 * @returns {number} The sum.
 */
function sumValues(obj) {
    return sumArray(Object.values(obj));
}
exports.sumValues = sumValues;
;
/**
 * Swaps the keys and values of a dictionary.
 * @template T
 * @param {T} dict - The dictionary.
 * @returns {StringDict} The swapped dictionary.
 */
function swapKeysAndValues(dict) {
    return Object.fromEntries(Object.entries(dict).map(entry => entry.toReversed()));
}
exports.swapKeysAndValues = swapKeysAndValues;
;
/**
 * Recursively applies a transform function to all keys in a nested object.
 * @template T
 * @param {T} data - The data to transform.
 * @param {(key: string) => string} transform - The transform function.
 * @returns {T} The transformed data.
 */
function transformKeys(data, transform) {
    if (Array.isArray(data)) {
        return data.map((value) => transformKeys(value, transform));
    }
    if (isRecord(data)) {
        return Object.fromEntries(Object.entries(data).map(([key, value]) => [
            transform(key),
            transformKeys(value, transform),
        ]));
    }
    return data;
}
exports.transformKeys = transformKeys;
;
/**
 * Truncates an array to a maximum length, logging if truncated.
 * @param {any[]} array - The array to truncate.
 * @param {number} maxRecords - The maximum length.
 * @param {Logger} [logger] - Logger instance.
 * @returns {any[]} The truncated array.
 */
function truncateToConfiguredLength(array, maxRecords, logger) {
    if (array.length &lt;= maxRecords)
        return array;
    logger ||= new logger_1.Logger("truncateToConfiguredLength()");
    const startLen = array.length;
    array = array.slice(0, maxRecords);
    logger.deep(`Truncated array of ${startLen} to ${array.length} (maxRecords=${maxRecords})`);
    return array;
}
exports.truncateToConfiguredLength = truncateToConfiguredLength;
;
/**
 * Returns a new array with only unique, non-null string values.
 * @param {(string | undefined)[]} array - The array to uniquify.
 * @returns {string[] | undefined} The unique array or undefined if empty.
 */
const uniquify = (array) => {
    if (array.length == 0)
        return undefined;
    let newArray = array.filter((e) => e != undefined);
    newArray = [...new Set(newArray)];
    return newArray;
};
exports.uniquify = uniquify;
/**
 * Removes elements of an array with duplicate values for a given property.
 * @template T
 * @param {T[]} rows - The array to uniquify.
 * @param {(obj: T) => string} transform - Function to get property.
 * @param {string} [logPrefix] - Log prefix.
 * @returns {T[]} The uniquified array.
 */
function uniquifyByProp(rows, transform, logPrefix) {
    const logger = new logger_1.Logger(logPrefix || 'collections_helpers', "uniquifyByProp()");
    const newRows = [...new Map(rows.map((element) => [transform(element), element])).values()];
    if (logPrefix &amp;&amp; newRows.length &lt; rows.length) {
        logger.trace(`Removed ${rows.length - newRows.length} duplicate rows`);
    }
    return newRows;
}
exports.uniquifyByProp = uniquifyByProp;
;
/**
 * Zips two arrays into a dictionary ([ 'a', 'b', 'c' ], [ 1, 2, 3 ] -> { a: 1, b: 2, c: 3 })
 * @template T
 * @param {string[]} array1 - Keys array.
 * @param {T[]} array2 - Values array.
 * @returns {Record&lt;string, T>} The zipped dictionary.
 */
function zipArrays(array1, array2) {
    return Object.fromEntries(array1.map((e, i) => [e, array2[i]]));
}
exports.zipArrays = zipArrays;
;
/**
 * Runs a list of promises in parallel and returns a dict of results keyed by input.
 * Raises error on isAccessTokenRevokedError(), otherwise just logs a warning and moves on
 * @template T
 * @param {string[]} args - The keys.
 * @param {(s: string) => Promise&lt;T>} promiser - The promise function.
 * @param {Logger} [logger] - Logger instance.
 * @returns {Promise&lt;Record&lt;string, T>>} The results dictionary.
 */
async function zipPromises(args, promiser, logger) {
    const allResults = zipArrays(args, await Promise.allSettled(args.map(promiser)));
    logger ||= new logger_1.Logger(`zipPromises`);
    return Object.entries(allResults).reduce((results, [arg, result]) => {
        if (result.status == "fulfilled") {
            results[arg] = result.value;
        }
        else {
            if ((0, api_1.isAccessTokenRevokedError)(result.reason)) {
                throw result.reason;
            }
            else {
                logger.warn(`Failure on argument "${arg}":`, result.reason);
            }
        }
        return results;
    }, {});
}
exports.zipPromises = zipPromises;
;
//# sourceMappingURL=collection_helpers.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Filters.html">Filters</a></li><li><a href="module-ObjWithCountList.html">ObjWithCountList</a></li><li><a href="module-Toot.html">Toot</a></li><li><a href="module-collection_helpers.html">collection_helpers</a></li></ul><h3>Classes</h3><ul><li><a href="Account.html">Account</a></li><li><a href="MastoApi.html">MastoApi</a></li><li><a href="NumericFilter.html">NumericFilter</a></li><li><a href="TheAlgorithm.html">TheAlgorithm</a></li><li><a href="UserData.html">UserData</a></li><li><a href="module-Filters-BooleanFilter.html">BooleanFilter</a></li><li><a href="module-ObjWithCountList-BooleanFilterOptionList.html">BooleanFilterOptionList</a></li><li><a href="module-ObjWithCountList-ObjWithCountList.html">ObjWithCountList</a></li><li><a href="module-ObjWithCountList-TagList.html">TagList</a></li><li><a href="module-Toot-Toot.html">Toot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#isAccessTokenRevokedError">isAccessTokenRevokedError</a></li><li><a href="global.html#isRateLimitError">isRateLimitError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Jun 09 2025 14:45:41 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
